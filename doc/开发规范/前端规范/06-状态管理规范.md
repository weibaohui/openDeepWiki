# 状态管理规范

本文档定义 React 状态管理的分类、原则和模式。

## 状态分类

| 类型       | 方案                 | 示例               |
| ---------- | -------------------- | ------------------ |
| 组件状态   | useState             | 表单输入、开关状态 |
| 跨组件状态 | Context + useReducer | 用户信息、主题设置 |
| 服务端状态 | useState + useEffect | API 数据           |
| URL 状态   | useSearchParams      | 筛选条件、分页     |

## 状态提升原则

- 状态应放在最近的共同父组件
- 避免过度使用全局状态
- 优先使用组件组合而非 Context

## 异步状态模式

```tsx
// 标准的异步数据获取模式
function useData<T>(fetcher: () => Promise<T>) {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const fetch = async () => {
    setLoading(true);
    setError(null);
    try {
      const result = await fetcher();
      setData(result);
    } catch (e) {
      setError(e as Error);
    } finally {
      setLoading(false);
    }
  };

  return { data, loading, error, refetch: fetch };
}
```

## 使用示例

```tsx
function RepositoryList() {
  const { data: repos, loading, error, refetch } = useData(
    () => repositoryApi.list().then(res => res.data)
  );

  useEffect(() => {
    refetch();
  }, []);

  if (loading) return <Skeleton />;
  if (error) return <ErrorMessage error={error} />;

  return (
    <ul>
      {repos?.map(repo => (
        <li key={repo.id}>{repo.name}</li>
      ))}
    </ul>
  );
}
```

## Context 使用场景

仅在以下场景使用 Context：

1. **主题切换**：全局主题状态
2. **国际化**：语言设置
3. **用户认证**：登录状态（如果需要）

## Context 示例

```tsx
// contexts/AppContext.tsx
interface AppState {
  sidebarOpen: boolean;
}

interface AppContextType {
  state: AppState;
  toggleSidebar: () => void;
}

const AppContext = createContext<AppContextType | null>(null);

export function AppProvider({ children }: { children: ReactNode }) {
  const [state, setState] = useState<AppState>({
    sidebarOpen: true,
  });

  const toggleSidebar = () => {
    setState(prev => ({ ...prev, sidebarOpen: !prev.sidebarOpen }));
  };

  return (
    <AppContext.Provider value={{ state, toggleSidebar }}>
      {children}
    </AppContext.Provider>
  );
}

export function useApp() {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useApp must be used within AppProvider');
  }
  return context;
}
```

## 相关文档

- [API 调用规范](./09-API调用规范.md)
- [最佳实践](./12-最佳实践.md)
