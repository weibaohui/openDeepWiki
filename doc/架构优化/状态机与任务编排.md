# 状态机与任务编排（仓库/任务一致性）架构优化建议

## 1. 现状概览

当前后端的状态更新与任务编排主要分布在两处：

- 仓库状态：
  - run-all 启动时置为 analyzing：[RepositoryService.RunAllTasks](../../../backend/internal/service/repository.go#L131-L149)
  - run-all 结束时状态更新逻辑不完整：[RepositoryService.runTasksAsync](../../../backend/internal/service/repository.go#L151-L182)循环结束后未正确更新仓库状态
  - clone 过程置为 cloning/ready/error：[RepositoryService.cloneAndAnalyze](../../../backend/internal/service/repository.go#L70-L102)
- 任务状态：
  - 任务运行时置 running/completed/failed：[TaskService.Run](../../../backend/internal/service/task.go#L59-L62,125-L127)
  - reset/force reset 直接改状态并删文档：[TaskService.Reset](../../../backend/internal/service/task.go#L173-L177)、[TaskService.ForceReset](../../../backend/internal/service/task.go#L201-L204)
  - 任务状态变更时调用 UpdateRepositoryStatus 更新仓库状态：[TaskService.UpdateRepositoryStatus](../../../backend/internal/service/task.go#L233-L292)

架构层面存在几个明显的"一致性缺口"：

1) 仓库状态聚合逻辑不完整  
- [RepositoryService.runTasksAsync](../../../backend/internal/service/repository.go#L151-L182)循环结束后未正确更新仓库状态，可能导致状态不一致  
- cleanup 卡住任务会把 task 置 failed，但 runTasksAsync 未处理这种情况下的仓库状态更新

2) 缺少明确的状态机与合法迁移约束  
- 字符串状态散落：repo/task 状态来自多处写入，缺少"允许的迁移路径"  
- 当前虽有 [UpdateRepositoryStatus](../../../backend/internal/service/task.go#L233-L292) 聚合逻辑，但未形成正式的状态机

3) 编排策略写死在 runTasksAsync 串行循环  
- 当前 run-all 只能串行执行，未来想并行、跳过、重试、优先级、限流都会牵扯大量改动  
- 多处直接使用 `go ...` 启动 goroutine，缺乏统一的任务调度机制

## 2. 建议目标：状态机 + 编排器（Orchestrator）

建议把“状态机（State Machine）”和“任务编排（Orchestration）”作为两个清晰的架构边界：

- **状态机**：定义状态集合、合法迁移、迁移触发事件与一致性修正策略
- **编排器**：负责把 Task 作为 Job 放进队列执行，控制并发、重试、超时、取消

与事件机制配合（建议先读 [事件机制.md](file:///Users/weibh/projects/go/openDeepWiki/doc/架构优化/事件机制.md)）后，可以做到：

- 状态变化由统一通道发布（task.status_changed -> 聚合器 -> repo.status_changed）
- 前端不再依赖轮询“猜测”系统状态

## 3. 状态机设计建议

### 3.1 Task 状态机（建议）

| 状态      | 说明                                                 |
| --------- | ---------------------------------------------------- |
| pending   | 未运行（初始态/重置态）                              |
| queued    | 已入队等待（建议新增）                               |
| running   | 正在执行                                             |
| succeeded | 执行成功（建议用 succeeded 替代 completed 更语义化） |
| failed    | 执行失败（可重试/不可重试可区分）                    |
| canceled  | 被取消（建议新增）                                   |

最小改造也可以不新增 queued/canceled，但 queued 对“编排器可观测性”帮助非常大。

合法迁移示例：

- pending -> queued -> running -> succeeded/failed
- running -> failed（超时/异常）
- queued/running -> canceled（用户取消）
- failed/succeeded/canceled -> pending（reset）

### 3.2 Repository 状态机（建议）

| 状态      | 说明                                     |
| --------- | ---------------------------------------- |
| pending   | 刚创建但还未克隆/未可用                  |
| cloning   | 正在拉取代码                             |
| ready     | 可执行任务（至少 clone 成功）            |
| analyzing | 任一任务处于 queued/running              |
| completed | 所有必选任务 succeeded                   |
| error     | 至少一个必选任务 failed，且未被修复/重试 |

关键点：仓库状态应该由“任务集合状态”推导，而不是由某个流程末尾写死设置。

## 4. 仓库状态聚合器（UpdateRepositoryStatus）

当前已有一个聚合器实现 [TaskService.UpdateRepositoryStatus](../../../backend/internal/service/task.go#L233-L292)，在以下场景被调用：

- task 状态变化（最关键）  
  - 在 [TaskService.Run](../../../backend/internal/service/task.go#L66,133) 中任务开始和完成时调用
  - 在 [TaskService.failTask](../../../backend/internal/service/task.go#L145) 中任务失败时调用
- task reset/force reset
  - 在 [TaskService.Reset](../../../backend/internal/service/task.go#L179) 和 [TaskService.ForceReset](../../../backend/internal/service/task.go#L210) 中调用
- cleanup 卡住任务
  - 通过 [TaskService.CleanupStuckTasks](../../../backend/internal/service/task.go#L215-L226) 更新数据库后，需要手动触发状态更新

### 4.1 聚合规则（建议默认规则）

给定仓库下任务集合 T：

1) 若存在 running/queued：repo = analyzing  
2) 否则若存在 failed：repo = error  
3) 否则若所有“必选任务”都 succeeded：repo = completed  
4) 否则：repo = ready

其中"必选任务"建议来自 TaskTypes（或进一步配置化），参见 [models.go](../../../backend/internal/model/models.go#L73-L85)。

### 4.2 幂等与并发一致性

建议把状态迁移做成“带前置条件的更新”，避免并发覆盖：

- 更新 task：`UPDATE tasks SET status=? WHERE id=? AND status IN (...)`
- 更新 repo：`UPDATE repositories SET status=? WHERE id=? AND status=?`

即使暂时使用 gorm，也建议引入 `RowsAffected` 检查，避免两个并发操作互相覆盖。

## 5. 任务编排器（Orchestrator）建议

### 5.1 为什么需要编排器

当前实现多个位置直接 `go ...`：

- 创建仓库后异步 clone：[RepositoryService.Create](../../../backend/internal/service/repository.go#L37-L68)
- run-all 异步执行：[RepositoryService.RunAllTasks](../../../backend/internal/service/repository.go#L131-L149)
- 单任务执行也起 goroutine：[TaskHandler.Run](../../../backend/internal/handler/task.go#L45-L47)

这种方式缺点是：

- 并发无上限：多用户/多仓库时 goroutine 数不可控
- 无队列：无法表达“排队中”
- 无取消：任务跑起来很难中断
- 可观测性弱：只能靠日志/DB 猜测当前到底在干什么

### 5.2 最小落地版（单实例内存队列）

引入一个全局 Orchestrator（worker pool）：

- 全局并发 N（例如 2~4），避免打爆 CPU/LLM 配额
- 每个 repo 并发 1（可选），保证同一仓库任务串行（除非后续支持并行）
- Job = taskID，worker 取出后调用现有 TaskService.Run（或拆分成可取消的 Runner）

配合状态机：

- 入队时：pending -> queued
- worker 开始：queued -> running
- worker 结束：running -> succeeded/failed

### 5.3 后续演进（分布式队列）

当需要多实例部署或更强可靠性时：

- 将队列迁移到 Redis Streams / BullMQ / NATS JetStream 等
- worker 可以水平扩展
- 事件总线也可从内存升级到 Redis/NATS

关键是：先把“状态机 + 事件协议 + 发布点”稳定下来，后续替换实现成本会显著降低。

## 6. API 层的编排语义建议

建议把“启动任务/重置任务”这类接口语义从“立即执行”改为“提交作业”：

- `POST /api/tasks/:id/run`：提交到队列，返回 {job_id, status: queued}
- `POST /api/repositories/:id/run-all`：按 sort_order 批量入队，返回 {enqueued: N}
- 可选：`POST /api/tasks/:id/cancel`：取消 queued/running 任务

这样前端可以更清晰地表达：排队中/运行中/已完成/失败。

## 7. 当前进展与下一步计划

### 当前已实现的部分：

- ✅ [TaskService.UpdateRepositoryStatus](../../../backend/internal/service/task.go#L233-L292)：实现了基于任务集合状态的仓库状态聚合逻辑
- ✅ 状态变更点调用：大部分任务状态变更都会触发仓库状态更新
- ✅ 幂等性考虑：UpdateRepositoryStatus 方法包含状态检查逻辑

### 仍需改进的问题：

- ⚠️ [RepositoryService.runTasksAsync](../../../backend/internal/service/repository.go#L151-L182) 循环结束后未显式更新仓库状态
- ⚠️ 缺少正式的状态机定义和状态迁移约束
- ⚠️ 任务编排仍使用简单的 goroutine，缺乏队列和并发控制

### 下一步实施建议：

1. **短期（1-2周）**：
   - 修复 runTasksAsync 的仓库状态更新问题
   - 补充缺失的状态变更点调用 UpdateRepositoryStatus
   - 添加状态迁移的日志记录便于调试

2. **中期（1个月）**：
   - 引入轻量级任务队列（如 worker pool）
   - 定义正式的状态机和合法迁移路径
   - 增加状态变更的前置条件检查

3. **长期（2-3个月）**：
   - 实现完整的任务编排器（Orchestrator）
   - 支持任务优先级、重试、取消等高级特性
   - 考虑分布式部署的队列和状态同步方案

