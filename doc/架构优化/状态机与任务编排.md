# 状态机与任务编排（仓库/任务一致性）架构优化建议

## 1. 现状概览

当前后端的状态更新与任务编排主要分布在两处：

- 仓库状态：
  - run-all 启动时置为 analyzing：[RepositoryService.RunAllTasks](file:///Users/weibh/projects/go/openDeepWiki/backend/services/repository.go#L114-L130)
  - run-all 结束时根据 failedCount 置为 completed/error：[RepositoryService.runTasksAsync](file:///Users/weibh/projects/go/openDeepWiki/backend/services/repository.go#L132-L159)
  - clone 过程置为 cloning/ready/error：[RepositoryService.cloneAndAnalyze](file:///Users/weibh/projects/go/openDeepWiki/backend/services/repository.go#L58-L82)
- 任务状态：
  - 任务运行时置 running/completed/failed：[TaskService.Run](file:///Users/weibh/projects/go/openDeepWiki/backend/services/task.go#L39-L129)
  - reset/force reset 直接改状态并删文档：[TaskService.Reset](file:///Users/weibh/projects/go/openDeepWiki/backend/services/task.go#L152-L166)、[TaskService.ForceReset](file:///Users/weibh/projects/go/openDeepWiki/backend/services/task.go#L169-L190)

架构层面存在几个明显的“一致性缺口”：

1) 仓库状态并非“任务集合状态”的可靠函数  
- 单独运行某个任务（`POST /api/tasks/:id/run`）不会驱动仓库状态变化。  
- cleanup 卡住任务会把 task 置 failed，但不修正仓库状态（仍可能停留在 analyzing）。

2) 缺少明确的状态机与合法迁移约束  
- 字符串状态散落：repo/task 状态来自多处写入，缺少“允许的迁移路径”。

3) 编排策略写死在 runTasksAsync 串行循环  
- 当前 run-all 只能串行执行，未来想并行、跳过、重试、优先级、限流都会牵扯大量改动。

## 2. 建议目标：状态机 + 编排器（Orchestrator）

建议把“状态机（State Machine）”和“任务编排（Orchestration）”作为两个清晰的架构边界：

- **状态机**：定义状态集合、合法迁移、迁移触发事件与一致性修正策略
- **编排器**：负责把 Task 作为 Job 放进队列执行，控制并发、重试、超时、取消

与事件机制配合（建议先读 [事件机制.md](file:///Users/weibh/projects/go/openDeepWiki/doc/架构优化/事件机制.md)）后，可以做到：

- 状态变化由统一通道发布（task.status_changed -> 聚合器 -> repo.status_changed）
- 前端不再依赖轮询“猜测”系统状态

## 3. 状态机设计建议

### 3.1 Task 状态机（建议）

| 状态 | 说明 |
|---|---|
| pending | 未运行（初始态/重置态） |
| queued | 已入队等待（建议新增） |
| running | 正在执行 |
| succeeded | 执行成功（建议用 succeeded 替代 completed 更语义化） |
| failed | 执行失败（可重试/不可重试可区分） |
| canceled | 被取消（建议新增） |

最小改造也可以不新增 queued/canceled，但 queued 对“编排器可观测性”帮助非常大。

合法迁移示例：

- pending -> queued -> running -> succeeded/failed
- running -> failed（超时/异常）
- queued/running -> canceled（用户取消）
- failed/succeeded/canceled -> pending（reset）

### 3.2 Repository 状态机（建议）

| 状态 | 说明 |
|---|---|
| pending | 刚创建但还未克隆/未可用 |
| cloning | 正在拉取代码 |
| ready | 可执行任务（至少 clone 成功） |
| analyzing | 任一任务处于 queued/running |
| completed | 所有必选任务 succeeded |
| error | 至少一个必选任务 failed，且未被修复/重试 |

关键点：仓库状态应该由“任务集合状态”推导，而不是由某个流程末尾写死设置。

## 4. 仓库状态聚合器（RepoStatusAggregator）

建议引入一个聚合器组件（可以是一个服务函数），在以下场景触发重算：

- task 状态变化（最关键）  
  - 例如在 [TaskService.Run](file:///Users/weibh/projects/go/openDeepWiki/backend/services/task.go#L39-L129) 每次改状态后触发
- task reset/force reset
- cleanup 卡住任务

### 4.1 聚合规则（建议默认规则）

给定仓库下任务集合 T：

1) 若存在 running/queued：repo = analyzing  
2) 否则若存在 failed：repo = error  
3) 否则若所有“必选任务”都 succeeded：repo = completed  
4) 否则：repo = ready

其中“必选任务”建议来自 TaskTypes（或进一步配置化），参见 [models.go](file:///Users/weibh/projects/go/openDeepWiki/backend/models/models.go#L73-L85)。

### 4.2 幂等与并发一致性

建议把状态迁移做成“带前置条件的更新”，避免并发覆盖：

- 更新 task：`UPDATE tasks SET status=? WHERE id=? AND status IN (...)`
- 更新 repo：`UPDATE repositories SET status=? WHERE id=? AND status=?`

即使暂时使用 gorm，也建议引入 `RowsAffected` 检查，避免两个并发操作互相覆盖。

## 5. 任务编排器（Orchestrator）建议

### 5.1 为什么需要编排器

当前实现多个位置直接 `go ...`：

- 创建仓库后异步 clone：[RepositoryService.Create](file:///Users/weibh/projects/go/openDeepWiki/backend/services/repository.go#L25-L56)
- run-all 异步执行：[RepositoryService.RunAllTasks](file:///Users/weibh/projects/go/openDeepWiki/backend/services/repository.go#L114-L130)
- 单任务执行也起 goroutine：[TaskHandler.Run](file:///Users/weibh/projects/go/openDeepWiki/backend/handlers/task.go#L39-L51)

这种方式缺点是：

- 并发无上限：多用户/多仓库时 goroutine 数不可控
- 无队列：无法表达“排队中”
- 无取消：任务跑起来很难中断
- 可观测性弱：只能靠日志/DB 猜测当前到底在干什么

### 5.2 最小落地版（单实例内存队列）

引入一个全局 Orchestrator（worker pool）：

- 全局并发 N（例如 2~4），避免打爆 CPU/LLM 配额
- 每个 repo 并发 1（可选），保证同一仓库任务串行（除非后续支持并行）
- Job = taskID，worker 取出后调用现有 TaskService.Run（或拆分成可取消的 Runner）

配合状态机：

- 入队时：pending -> queued
- worker 开始：queued -> running
- worker 结束：running -> succeeded/failed

### 5.3 后续演进（分布式队列）

当需要多实例部署或更强可靠性时：

- 将队列迁移到 Redis Streams / BullMQ / NATS JetStream 等
- worker 可以水平扩展
- 事件总线也可从内存升级到 Redis/NATS

关键是：先把“状态机 + 事件协议 + 发布点”稳定下来，后续替换实现成本会显著降低。

## 6. API 层的编排语义建议

建议把“启动任务/重置任务”这类接口语义从“立即执行”改为“提交作业”：

- `POST /api/tasks/:id/run`：提交到队列，返回 {job_id, status: queued}
- `POST /api/repositories/:id/run-all`：按 sort_order 批量入队，返回 {enqueued: N}
- 可选：`POST /api/tasks/:id/cancel`：取消 queued/running 任务

这样前端可以更清晰地表达：排队中/运行中/已完成/失败。

## 7. 验收标准（建议）

当完成本文件的改造后，应满足：

- 任意方式触发任务运行（单任务/run-all/重试/cleanup）都能让仓库状态正确变化
- 仓库状态只由聚合规则决定，不依赖某个流程末尾硬编码
- 同一 taskID 不会被并发执行两次（幂等/互斥保证）
- 系统在高并发触发下不会创建无限 goroutine（有队列与并发上限）

