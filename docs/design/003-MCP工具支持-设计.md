# 003-MCP工具支持-设计.md

## 1. 设计目标

为 LLM Client 增加 MCP (Model Context Protocol) 工具调用能力，使大模型能够在代码分析过程中主动获取文件信息、执行命令，提升文档生成的准确性和深度。

## 2. 架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                     LLM Client                              │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │   Chat()    │  │ChatWithTools│  │ChatWithToolExecution│  │
│  └─────────────┘  └──────┬──────┘  └──────────┬──────────┘  │
│                          │                    │             │
│                          ▼                    ▼             │
│                   ┌──────────────────────────────────────┐  │
│                   │         Tool Executor                │  │
│                   │  ┌─────────┐  ┌──────────────────┐   │  │
│                   │  │ Registry│  │ Safety Validator │   │  │
│                   │  └────┬────┘  └──────────────────┘   │  │
│                   └───────┼──────────────────────────────┘  │
│                           │                                 │
└───────────────────────────┼─────────────────────────────────┘
                            │
        ┌───────────────────┼───────────────────┐
        ▼                   ▼                   ▼
   ┌─────────┐       ┌─────────┐       ┌─────────────┐
   │ File    │       │ Search  │       │   Bash      │
   │ Tools   │       │ Tools   │       │   Tools     │
   └─────────┘       └─────────┘       └─────────────┘
```

### 2.2 核心组件

| 组件 | 职责 | 文件 |
|------|------|------|
| LLM Client | 扩展支持 Tools 的 Chat 方法 | `client.go` |
| Type System | Tool、ToolCall、ToolResult 等类型定义 | `types.go` |
| Tool Registry | 工具注册和发现 | `executor.go` |
| Safety Validator | 路径安全检查、命令过滤 | `executor.go` |
| Tool Implementations | 各工具的具体实现 | `tools/*.go` |

## 3. 数据模型

### 3.1 Tool 定义

```go
// Tool 符合 OpenAI Function Calling 格式的工具定义
type Tool struct {
    Type     string       `json:"type"` // "function"
    Function ToolFunction `json:"function"`
}

type ToolFunction struct {
    Name        string          `json:"name"`
    Description string          `json:"description"`
    Parameters  ParameterSchema `json:"parameters"`
}

type ParameterSchema struct {
    Type       string              `json:"type"` // "object"
    Properties map[string]Property `json:"properties"`
    Required   []string            `json:"required"`
}
```

### 3.2 Tool Call 与结果

```go
// ToolCall LLM 返回的调用请求
type ToolCall struct {
    ID       string       `json:"id"`
    Type     string       `json:"type"`
    Function FunctionCall `json:"function"`
}

type FunctionCall struct {
    Name      string `json:"name"`
    Arguments string `json:"arguments"` // JSON string
}

// ToolResult 工具执行结果
type ToolResult struct {
    Content string `json:"content"`
    IsError bool   `json:"is_error"`
}
```

## 4. 接口设计

### 4.1 新增 Client 方法

```go
// ChatWithTools 发送带 Tools 定义的请求
func (c *Client) ChatWithTools(ctx context.Context, messages []ChatMessage, tools []Tool) (*ChatResponse, error)

// ChatWithToolExecution 完整的多轮 Tool Call 处理
func (c *Client) ChatWithToolExecution(ctx context.Context, messages []ChatMessage, tools []Tool, basePath string) (string, error)
```

### 4.2 Tool Executor 接口

```go
type ToolExecutor interface {
    Execute(ctx context.Context, toolCall ToolCall) (ToolResult, error)
    RegisterTool(name string, handler ToolHandler, schema Tool)
}

type ToolHandler func(ctx context.Context, args json.RawMessage, basePath string) (string, error)
```

## 5. 工具实现细节

### 5.1 search_files

- 使用 `filepath.Glob` 或 `filepath.Walk` 实现
- 支持 `**` glob 模式（使用自定义实现或第三方库）
- 返回相对路径列表

### 5.2 read_file

- 使用 `os.ReadFile` 读取
- 支持行号范围（offset + limit）
- 大文件截断处理

### 5.3 search_text

- 使用 `regexp` 或字符串匹配
- 支持文件过滤（glob 模式）
- 返回匹配文件及行号、内容预览

### 5.4 execute_bash

- 使用 `exec.CommandContext` 实现超时控制
- 严格命令白名单/黑名单检查
- 工作目录限制

### 5.5 count_lines

- 文件：直接读取统计
- 目录：遍历匹配文件统计总行数
- 支持 glob 过滤

## 6. 安全设计

### 6.1 路径安全

```go
func validatePath(basePath, targetPath string) error {
    absBase, _ := filepath.Abs(basePath)
    absTarget, _ := filepath.Abs(filepath.Join(basePath, targetPath))
    if !strings.HasPrefix(absTarget, absBase) {
        return fmt.Errorf("path escapes base directory: %s", targetPath)
    }
    return nil
}
```

### 6.2 命令安全

```go
var dangerousCommands = []string{"rm", "mv", "dd", ">", "|", ";", "&&", "$(", "`"}

func validateCommand(command string) error {
    // 1. 检查危险字符
    // 2. 检查危险命令
    // 3. 仅允许白名单命令（可选更严格策略）
}
```

### 6.3 资源限制

| 限制项 | 默认值 | 说明 |
|--------|--------|------|
| MaxFileSize | 1MB | 单次读取文件大小上限 |
| CommandTimeout | 30s | 命令执行超时时间 |
| MaxResults | 100 | 搜索结果返回数量上限 |
| MaxToolRounds | 10 | 多轮 Tool Call 最大轮数 |

## 7. 文件组织

```
backend/internal/pkg/llm/
├── client.go          # 修改：扩展 Chat 方法
├── types.go           # 新增：类型定义
├── executor.go        # 新增：执行器核心
└── tools/
    ├── search_files.go  # search_files 工具
    ├── read_file.go     # read_file 工具
    ├── search_text.go   # search_text 工具
    ├── execute_bash.go  # execute_bash 工具
    └── count_lines.go   # count_lines 工具
```

## 8. 关键实现决策

### 8.1 关于 glob 模式 `**`

Go 标准库的 `filepath.Glob` 不支持 `**`（递归匹配），将使用以下方案：
- 简单模式（如 `*.go`）：使用 `filepath.Glob`
- 递归模式（如 `**/*.go`）：使用 `filepath.Walk` 自定义实现

### 8.2 关于命令执行

采用**黑名单 + 白名单**双层策略：
1. 黑名单：绝对禁止危险字符和命令
2. 白名单：推荐只允许特定命令（grep, wc, find, cat, echo, ls 等）

### 8.3 关于错误处理

- 工具执行错误：返回 `ToolResult{IsError: true, Content: errorMsg}`
- 系统错误：直接返回 error
- LLM 调用错误：直接返回 error

## 9. 使用示例

```go
// 创建 Client
client := llm.NewClient(baseURL, apiKey, model, maxTokens)

// 准备消息
messages := []llm.ChatMessage{
    {Role: "system", Content: "你是一个代码分析助手。请使用工具获取所需信息。"},
    {Role: "user", Content: "分析这个 Go 项目的架构"},
}

// 执行带工具的对话（使用默认工具集合）
response, err := client.ChatWithToolExecution(ctx, messages, llm.DefaultTools(repoPath), repoPath)
if err != nil {
    log.Fatal(err)
}

fmt.Println(response) // LLM 生成的分析结果
```

## 10. 风险缓解

| 风险 | 缓解措施 |
|------|----------|
| 路径遍历 | 严格的 Abs + Prefix 检查 |
| 命令注入 | 黑名单过滤 + 白名单限制 |
| 资源耗尽 | 超时控制 + 大小限制 |
| Token 爆炸 | 结果截断 + 最大轮数限制 |
