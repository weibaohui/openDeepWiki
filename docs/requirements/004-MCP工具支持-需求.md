# 004-MCP工具支持-需求.md

## 1. 背景（Why）

当前 `backend/internal/pkg/llm/client.go` 中的 LLM 客户端仅实现了基础的对话能力（`Chat` 和 `GenerateDocument` 方法），无法向大模型传递 Tools/Functions 定义，也无法处理模型返回的 Tool Calls 请求。这限制了系统的代码分析能力——大模型只能基于已有上下文进行推理，无法在需要时主动获取更多信息（如搜索文件、读取文件内容、执行命令等）。

引入 MCP (Model Context Protocol) 工具支持后，系统可以：
- 让大模型在分析代码时主动搜索相关文件
- 让大模型读取文件内容以获取更准确的上下文
- 让大模型执行命令（如 grep、wc）来收集代码统计信息
- 大幅提升生成文档的准确性和深度

## 2. 目标（What，必须可验证）

- [ ] **MCP协议支持**：扩展 LLM Client 支持以 MCP 协议方式传递 Tools 定义
- [ ] **工具集合实现**：实现以下核心工具的调用能力：
  - `search_files`：按文件名模式搜索文件
  - `read_file`：读取文件内容
  - `search_text`：在文件内容中搜索关键字（grep 能力）
  - `execute_bash`：执行 bash 命令
  - `count_lines`：统计文件行数（wc 能力）
- [ ] **Tool Call 处理**：实现 Tool Call 请求解析、工具执行、结果回传完整流程
- [ ] **安全沙箱**：工具执行必须在安全约束下进行，防止越权操作
- [ ] **LLM Client 增强**：提供带 Tools 的 Chat 方法，支持多轮 Tool Call 交互

## 3. 非目标（Explicitly Out of Scope）

- [ ] 不实现完整的 MCP Server 协议（只实现 Client 侧的 Tools 传递和调用）
- [ ] 不支持文件写入/修改类工具（如 write_file、edit_file）
- [ ] 不支持网络访问类工具（如 fetch_url、http_request）
- [ ] 不支持需要用户交互的工具（如需要确认的危险操作）
- [ ] 不实现工具调用结果的持久化存储
- [ ] 不支持除 OpenAI 兼容接口外的其他 LLM 协议

## 4. 使用场景 / 用户路径

### 场景 1：分析时自动搜索相关文件

```
任务：生成项目架构文档
    ↓
调用 LLM Chat with Tools
    ↓
LLM: "我需要了解项目的模块结构，先搜索一下所有 go.mod 文件"
    ↓
执行 Tool Call: search_files(pattern="**/go.mod")
    ↓
返回结果: ["backend/go.mod", "frontend/go.mod", "pkg/utils/go.mod"]
    ↓
LLM: "让我读取主模块的 go.mod 了解依赖"
    ↓
执行 Tool Call: read_file(path="backend/go.mod")
    ↓
返回文件内容
    ↓
LLM 基于获取的信息生成准确的架构文档
```

### 场景 2：统计代码行数辅助分析

```
任务：分析项目规模
    ↓
调用 LLM Chat with Tools
    ↓
LLM: "我需要统计各类代码文件的数量"
    ↓
执行 Tool Call: execute_bash(command="find . -name '*.go' | wc -l")
    ↓
返回结果: 156
    ↓
执行 Tool Call: execute_bash(command="find . -name '*.ts' -o -name '*.tsx' | wc -l")
    ↓
返回结果: 89
    ↓
LLM 生成包含项目规模信息的文档
```

### 场景 3：搜索特定接口实现

```
任务：分析业务逻辑流程
    ↓
调用 LLM Chat with Tools
    ↓
LLM: "我需要找到所有实现了 Repository 接口的文件"
    ↓
执行 Tool Call: search_text(pattern="type.*Repository.*interface", glob="*.go")
    ↓
返回匹配结果及文件路径
    ↓
LLM: "让我读取这些文件了解接口定义"
    ↓
执行 Tool Call: read_file(path="backend/internal/repository/repo_repo.go")
    ↓
LLM 生成准确的业务逻辑文档
```

## 5. 功能需求清单（Checklist）

### 5.1 MCP 工具定义（Tool Definitions）

- [ ] 定义 Tool 结构体，符合 OpenAI Function Calling 格式：
  - `Name`: 工具名称
  - `Description`: 工具描述
  - `Parameters`: JSON Schema 格式的参数定义

- [ ] 实现以下工具的 Schema 定义：

| 工具名 | 描述 | 参数 |
|--------|------|------|
| `search_files` | 按模式搜索文件 | `pattern`: glob 模式，如 `**/*.go`<br>`path`: 搜索路径（可选，默认当前目录） |
| `read_file` | 读取文件内容 | `path`: 文件路径<br>`offset`: 起始行号（可选）<br>`limit`: 最大行数（可选，默认 100） |
| `search_text` | 在文件中搜索文本 | `pattern`: 正则表达式或字符串<br>`path`: 搜索路径（可选）<br>`glob`: 文件匹配模式（可选） |
| `execute_bash` | 执行 bash 命令 | `command`: 命令字符串<br>`timeout`: 超时时间秒数（可选，默认 30）<br>`cwd`: 工作目录（可选） |
| `count_lines` | 统计文件行数 | `path`: 文件或目录路径<br>`pattern`: 文件匹配模式（可选） |

### 5.2 工具执行器（Tool Executor）

- [ ] 设计工具执行器接口：
```go
type ToolExecutor interface {
    Execute(ctx context.Context, toolCall ToolCall) (ToolResult, error)
}
```

- [ ] 实现各工具的具体执行逻辑：
  - `search_files`: 使用 `filepath.Glob` 或 `filepath.Walk` 实现
  - `read_file`: 使用 `os.ReadFile` 实现，支持行号范围读取
  - `search_text`: 使用 `regexp` + 文件遍历实现
  - `execute_bash`: 使用 `exec.CommandContext` 实现
  - `count_lines`: 使用 `wc` 命令或自行实现行数统计

- [ ] 实现执行结果结构：
```go
type ToolResult struct {
    Content string `json:"content"`  // 执行结果内容
    IsError bool   `json:"is_error"` // 是否执行出错
}
```

### 5.3 LLM Client 增强

- [ ] 扩展 `ChatMessage` 结构支持 `ToolCalls` 和 `ToolCallID`：
```go
type ChatMessage struct {
    Role         string     `json:"role"`
    Content      string     `json:"content"`
    ToolCalls    []ToolCall `json:"tool_calls,omitempty"`
    ToolCallID   string     `json:"tool_call_id,omitempty"`
}
```

- [ ] 扩展 `ChatRequest` 支持 `Tools` 字段：
```go
type ChatRequest struct {
    Model       string        `json:"model"`
    Messages    []ChatMessage `json:"messages"`
    Tools       []Tool        `json:"tools,omitempty"`
    ToolChoice  string        `json:"tool_choice,omitempty"`
    MaxTokens   int           `json:"max_tokens,omitempty"`
    Temperature float64       `json:"temperature,omitempty"`
}
```

- [ ] 新增带 Tools 的 Chat 方法：
```go
func (c *Client) ChatWithTools(ctx context.Context, messages []ChatMessage, tools []Tool) (*ChatResponse, error)
```

- [ ] 实现 Tool Call 自动处理流程：
```go
func (c *Client) ChatWithToolExecution(ctx context.Context, messages []ChatMessage, tools []Tool, executor ToolExecutor) (string, error)
```
该方法应：
1. 发送请求到 LLM
2. 如果返回 Tool Calls，执行对应工具
3. 将结果回传给 LLM
4. 重复直到获得最终文本响应
5. 返回最终响应内容

### 5.4 安全约束机制

- [ ] 实现路径安全检查：
  - 所有文件操作必须在指定工作目录内
  - 禁止访问工作目录外的文件（如 `/etc/passwd`, `../../etc/passwd`）

- [ ] 实现命令白名单/黑名单：
  - 禁止执行危险命令（如 `rm -rf`, `>`, `|` 管道等）
  - 或限制仅允许特定命令（grep, wc, find, cat 等）

- [ ] 实现资源限制：
  - 命令执行超时控制（默认 30s，最大 120s）
  - 文件读取大小限制（最大 1MB）
  - 搜索结果数量限制（最大 100 条）

### 5.5 代码集成

- [ ] 在 `backend/internal/pkg/llm/` 下新建文件组织：
```
backend/internal/pkg/llm/
├── client.go          # 现有文件，扩展支持 Tools
├── types.go           # 新增：类型定义（Tool, ToolCall, ToolResult 等）
├── executor.go        # 新增：工具执行器接口和实现
└── tools/
    ├── search_files.go  # search_files 工具实现
    ├── read_file.go     # read_file 工具实现
    ├── search_text.go   # search_text 工具实现
    ├── execute_bash.go  # execute_bash 工具实现
    └── count_lines.go   # count_lines 工具实现
```

## 6. 约束条件

### 6.1 技术约束

- 必须使用 Go 语言实现，符合项目现有编码规范
- 必须兼容 OpenAI API 格式的 Function Calling 协议
- 工具执行必须在指定工作目录（repository 目录）内进行
- 文件读取必须使用缓冲方式，避免大文件导致 OOM

### 6.2 架构约束

- 工具定义与工具执行逻辑必须解耦
- LLM Client 不负责具体工具执行，只负责协议转换
- 工具执行器必须可扩展，便于后续添加新工具
- 不得修改现有的 `Chat` 方法签名，保持向后兼容

### 6.3 安全约束

- **路径安全**：所有文件路径必须经过 `filepath.Clean` 和边界检查
- **命令安全**：execute_bash 必须严格限制可执行命令范围
- **资源限制**：必须实现超时控制和大小限制
- **错误处理**：工具执行错误不得泄露敏感系统信息

### 6.4 性能约束

- 单次 Tool Call 执行时间 < 30s（可配置）
- 文件读取大小限制 < 1MB
- 搜索结果返回数量 < 100 条
- 多轮 Tool Call 交互最大轮数限制（如 10 轮）

## 7. 可修改 / 不可修改项

- ❌ **不可修改**：
  - 现有 `Chat` 方法签名和行为
  - `ChatMessage` 的基本字段（role, content）
  - 现有 LLM Client 的初始化方式
  
- ✅ **可调整**：
  - 工具的具体参数定义（如新增可选参数）
  - 安全限制的阈值（超时时间、文件大小限制等）
  - 工具执行器的内部实现方式
  - 错误信息的格式和内容

## 8. 接口与数据约定

### 8.1 工具定义结构

```go
// Tool 工具定义
type Tool struct {
    Type     string      `json:"type"` // 固定为 "function"
    Function ToolFunction `json:"function"`
}

// ToolFunction 函数定义
type ToolFunction struct {
    Name        string      `json:"name"`
    Description string      `json:"description"`
    Parameters  ParameterSchema `json:"parameters"`
}

// ParameterSchema JSON Schema 参数定义
type ParameterSchema struct {
    Type       string                 `json:"type"`
    Properties map[string]Property    `json:"properties"`
    Required   []string               `json:"required,omitempty"`
}

// Property 参数属性
type Property struct {
    Type        string `json:"type"`
    Description string `json:"description"`
}
```

### 8.2 Tool Call 结构

```go
// ToolCall LLM 返回的工具调用请求
type ToolCall struct {
    ID       string       `json:"id"`
    Type     string       `json:"type"` // 固定为 "function"
    Function FunctionCall `json:"function"`
}

// FunctionCall 函数调用详情
type FunctionCall struct {
    Name      string `json:"name"`
    Arguments string `json:"arguments"` // JSON 字符串
}
```

### 8.3 预定义工具集合

```go
// DefaultTools 返回默认工具集合
func DefaultTools(basePath string) []Tool {
    return []Tool{
        SearchFilesTool(),
        ReadFileTool(),
        SearchTextTool(),
        ExecuteBashTool(basePath),
        CountLinesTool(),
    }
}
```

### 8.4 使用示例

```go
// 创建带安全约束的工具执行器
executor := llm.NewSafeExecutor(repoPath, &llm.SafeExecutorConfig{
    MaxFileSize:   1024 * 1024, // 1MB
    CommandTimeout: 30 * time.Second,
    MaxResults:    100,
})

// 准备工具列表
tools := llm.DefaultTools(repoPath)

// 执行带工具的对话
messages := []llm.ChatMessage{
    {Role: "system", Content: "你是一个代码分析助手..."},
    {Role: "user", Content: "分析这个项目的架构"},
}

response, err := client.ChatWithToolExecution(ctx, messages, tools, executor)
```

## 9. 验收标准（Acceptance Criteria）

### 9.1 功能验收

- 如果调用 `ChatWithTools` 传入 Tools 定义，请求体必须包含正确的 `tools` JSON 字段
- 如果 LLM 返回 Tool Call，系统必须能正确解析 `tool_calls` 字段
- 如果执行 `search_files(pattern="**/*.go")`，必须返回所有匹配 `.go` 后缀的文件列表
- 如果执行 `read_file(path="README.md")`，必须返回文件内容字符串
- 如果执行 `search_text(pattern="func main", glob="*.go")`，必须返回所有包含 `func main` 的 Go 文件路径及匹配行
- 如果执行 `execute_bash(command="echo hello")`，必须返回命令输出 `hello`
- 如果执行 `count_lines(path=".", pattern="*.go")`，必须返回 Go 文件总行数

### 9.2 安全验收

- 如果尝试执行 `read_file(path="/etc/passwd")`，必须返回权限错误
- 如果尝试执行 `execute_bash(command="rm -rf /")`，必须拒绝执行并返回错误
- 如果尝试读取超过 1MB 的文件，必须截断或返回错误
- 如果命令执行超过 30s，必须超时并返回错误

### 9.3 协议验收

- Tool Call 请求和响应必须符合 OpenAI Function Calling 格式
- 多轮 Tool Call 交互必须能正确维护对话上下文
- Tool 执行结果回传后，LLM 必须能正确理解并继续对话

## 10. 风险与已知不确定点

| 风险 | 影响 | 对策 |
|------|------|------|
| LLM 选择不调用工具 | 中 | 在 system prompt 中明确说明何时应该使用工具；设置 `tool_choice: "auto"` |
| 工具执行结果过大 | 中 | 实施结果截断策略；限制返回内容长度；对大量结果进行摘要 |
| 多轮 Tool Call 导致 token 消耗过高 | 中 | 限制最大交互轮数；设置合理的 max_tokens；监控 token 使用 |
| 命令注入攻击 | 高 | 严格的命令白名单/黑名单；禁止特殊字符；使用参数化命令 |
| 路径遍历攻击 | 高 | 严格的路径边界检查；使用 `filepath.Clean` 和前缀检查 |
| 不同 LLM 对 Tools 支持程度不同 | 低 | 初期仅支持 OpenAI 兼容接口；后续根据需求扩展 |

## 11. 依赖关系

- 无前置依赖，可独立开发
- 完成后可被 `analyzer` 服务使用，增强代码分析能力

## 12. 实现提示

### 12.1 路径安全检查示例

```go
func isPathSafe(basePath, targetPath string) bool {
    absBase, _ := filepath.Abs(basePath)
    absTarget, _ := filepath.Abs(filepath.Join(basePath, targetPath))
    return strings.HasPrefix(absTarget, absBase)
}
```

### 12.2 命令安全过滤示例

```go
var dangerousPatterns = []string{
    `rm\s+-[rf]*[rf]`,  // rm -rf
    `>`,                // 重定向
    `\|`,               // 管道
    `;`,                // 命令分隔
    `&&`,               // 逻辑与
    `\$\(`,             // 命令替换
    '`',                // 反引号
}

func isCommandSafe(command string) bool {
    for _, pattern := range dangerousPatterns {
        if matched, _ := regexp.MatchString(pattern, command); matched {
            return false
        }
    }
    return true
}
```

### 12.3 Tool Call 处理流程示例

```go
func (c *Client) ChatWithToolExecution(ctx context.Context, messages []ChatMessage, tools []Tool, executor ToolExecutor) (string, error) {
    maxRounds := 10
    for i := 0; i < maxRounds; i++ {
        resp, err := c.ChatWithTools(ctx, messages, tools)
        if err != nil {
            return "", err
        }
        
        // 如果没有 Tool Calls，直接返回内容
        if len(resp.ToolCalls) == 0 {
            return resp.Content, nil
        }
        
        // 执行 Tool Calls
        for _, tc := range resp.ToolCalls {
            result, err := executor.Execute(ctx, tc)
            
            // 添加 assistant 的 tool_call 消息
            messages = append(messages, ChatMessage{
                Role:      "assistant",
                ToolCalls: []ToolCall{tc},
            })
            
            // 添加 tool 的结果消息
            content := result.Content
            if result.IsError {
                content = fmt.Sprintf("Error: %s", content)
            }
            messages = append(messages, ChatMessage{
                Role:       "tool",
                ToolCallID: tc.ID,
                Content:    content,
            })
        }
    }
    
    return "", fmt.Errorf("exceeded maximum tool call rounds (%d)", maxRounds)
}
```

## 13. 后续优化方向

- [ ] 支持更多工具（如 `list_directory`, `file_info`, `git_log` 等）
- [ ] 支持工具调用结果缓存，避免重复执行
- [ ] 支持工具调用历史记录和审计
- [ ] 支持用户自定义工具
- [ ] 支持工具调用结果的可视化展示
