# 数据表导入导出功能 - 需求文档

## 1. 功能概述

开发一个数据表导入导出功能，支持将 Task 和 Document 两个表中的内容，按 RepositoryID 在两个不同的 openDeepWiki 实例之间进行同步。

## 2. 使用场景

### 2.1 场景描述

假设有两个 openDeepWiki 实例：
- **实例 A**（源）：源数据服务器，包含已经分析完成的仓库数据
- **实例 B**（目标）：目标数据服务器，需要接收同步的数据

**典型使用流程**：
1. 用户在实例 A 上打开同步页面
2. 在"远端服务器"输入框中填写实例 B 的同步接口地址（如：`http://b-server/api/sync`）
3. 在"待同步仓库"下拉框中选择要同步的代码仓库（如：`repo-xxxx`）
4. 点击"开始同步"按钮
5. 系统自动将该仓库的所有 Task 和 Document 数据同步到实例 B
6. 显示同步进度和结果

### 2.2 应用场景

- **数据备份与恢复**：定期将生产环境数据同步到备用环境
- **多环境数据迁移**：从测试环境同步数据到生产环境
- **分布式部署**：在多个地理位置部署的实例间共享分析结果
- **数据聚合**：将多个实例的分析结果汇总到一个中心实例

## 3. 功能需求

### 3.1 核心功能

#### 3.1.1 同步接口（接收端 - 实例 B）

**接口 0：Repository 创建/更新接口**
- **路径**：`POST /api/sync/repository-upsert`
- **功能**：在接收端创建或更新 Repository 记录，保证后续 Task 与 Document 关联仓库存在
- **请求参数**：
  ```json
  {
    "repository_id": "repo-xxx",
    "name": "repo-xxx",
    "url": "https://github.com/org/repo-xxx",
    "branch": "main",
    "status": "ready",
    "created_at": "2024-01-01T00:00:00Z",
    "updated_at": "2024-01-01T00:00:00Z",
    "metadata": {}  // 其他 Repository 字段
  }
  ```
- **响应**：
  ```json
  {
    "code": "OK",
    "data": {
      "repository_id": "80",
      "name": "repo-xxx"
    }
  }
  ```

**接口 1：Task 创建接口**
- **路径**：`POST /api/sync/task-create`
- **功能**：在接收端创建一个新的 Task 记录
- **请求参数**：
  ```json
  {
    "repository_id": "80",
    "task_type": "overview",
    "status": "completed",
    "created_at": "2024-01-01T00:00:00Z",
    "updated_at": "2024-01-01T00:00:00Z",
    "metadata": {}  // 其他 Task 字段
  }
  ```
- **响应**：
  ```json
  {
    "code": "OK",
    "data": {
      "task_id": 100,  // 接收端创建的新 Task ID
      "repository_id": "80",
      "task_type": "overview"
    }
  }
  ```

**接口 2：Document 创建接口**
- **路径**：`POST /api/sync/document-create`
- **功能**：在接收端创建一个新的 Document 记录，关联到指定的 Task
- **请求参数**：
  ```json
  {
    "repository_id": "80",
    "task_id": 100,  // 接收端的 Task ID
    "document_type": "overview",
    "content": "文档内容",
    "language": "zh",
    "created_at": "2024-01-01T00:00:00Z",
    "updated_at": "2024-01-01T00:00:00Z",
    "metadata": {}  // 其他 Document 字段
  }
  ```
- **响应**：
  ```json
  {
    "code": "OK",
    "data": {
      "document_id": 200,  // 接收端创建的新 Document ID
      "repository_id": "80",
      "task_id": 100
    }
  }
  ```

**接口 3：Task 更新 DocumentID 接口**
- **路径**：`POST /api/sync/task-update-docid`
- **功能**：更新接收端 Task 记录的 DocumentID 字段
- **请求参数**：
  ```json
  {
    "task_id": 100,
    "document_id": 200
  }
  ```
- **响应**：
  ```json
  {
    "code": "OK",
    "data": {
      "task_id": 100,
      "document_id": 200
    }
  }
  ```

#### 3.1.2 同步控制接口（发起端 - 实例 A）

**接口 4：同步入口接口**
- **路径**：`POST /api/sync`
- **功能**：发起数据同步请求
- **请求参数**：
  ```json
  {
    "target_server": "http://b-server/api/sync",
    "repository_id": "80"
  }
  ```
- **响应**：
  ```json
  {
    "code": "OK",
    "data": {
      "sync_id": "sync-uuid-xxx",
      "repository_id": "80",
      "total_tasks": 10,
      "status": "in_progress"
    }
  }
  ```

**接口 5：同步状态查询**
- **路径**：`GET /api/sync/status/:sync_id`
- **功能**：查询同步任务的执行状态
- **响应**：
  ```json
  {
    "code": "OK",
    "data": {
      "sync_id": "sync-uuid-xxx",
      "repository_id": "80",
      "total_tasks": 10,
      "completed_tasks": 5,
      "failed_tasks": 0,
      "status": "in_progress",
      "current_task": "正在同步第 5 个文档",
      "started_at": "2024-01-01T00:00:00Z",
      "updated_at": "2024-01-01T00:00:05Z"
    }
  }
  ```

### 3.2 同步流程

#### 3.2.1 逐个 Document 同步流程

对于每个 Document（及其关联的 Task），同步流程如下：

0. **Repository 同步阶段**
   - 从实例 A 读取 Repository 基本信息
   - 调用实例 B 的 `/api/sync/repository-upsert` 接口
   - 确保接收端 Repository 已存在或已更新

1. **Task 创建阶段**
   - 从实例 A 读取 Task 数据（不包含 DocumentID）
   - 调用实例 B 的 `/api/sync/task-create` 接口
   - 接收实例 B 返回的新 Task ID（记为 `task_id_b`）
   - 建立 A 和 B 的 Task ID 映射关系：`task_id_a → task_id_b`

2. **Document 创建阶段**
   - 从实例 A 读取 Document 数据
   - 将 Task ID 替换为 `task_id_b`
   - 调用实例 B 的 `/api/sync/document-create` 接口
   - 接收实例 B 返回的新 Document ID（记为 `document_id_b`）
   - 建立 A 和 B 的 Document ID 映射关系：`document_id_a → document_id_b`

3. **Task 更新阶段**
   - 调用实例 B 的 `/api/sync/task-update-docid` 接口
   - 将 `task_id_b` 的 DocumentID 字段更新为 `document_id_b`

4. **完成该 Document 同步**
   - 记录同步成功
   - 继续下一个 Document

#### 3.2.2 完整同步流程

```
1. 用户在实例 A 上发起同步请求
   ↓
2. 验证目标服务器连通性
   ↓
3. 同步 Repository 基本信息到实例 B
   ↓
4. 查询指定 repository_id 的所有 Task
   ↓
5. 对每个 Task（按顺序）：
   5.1 调用 B 的 /api/sync/task-create
   5.2 调用 B 的 /api/sync/document-create
   5.3 调用 B 的 /api/sync/task-update-docid
   5.4 更新同步进度
   ↓
6. 全部同步完成后，返回最终结果
```

### 3.3 前端界面

#### 3.3.1 同步页面

**页面路径**：`/sync`

**页面布局**：
```
┌─────────────────────────────────────────────┐
│  数据同步                                    │
├─────────────────────────────────────────────┤
│                                              │
│  目标服务器：                                │
│  ┌─────────────────────────────────────┐   │
│  │ http://b-server/api/sync            │   │
│  └─────────────────────────────────────┘   │
│                                              │
│  待同步仓库：                                │
│  ┌─────────────────────────────────────┐   │
│  │ repo-xxx (v)                          │   │
│  │ repo-yyy                              │   │
│  └─────────────────────────────────────┘   │
│                                              │
│  ┌─────────────────────────────────────┐   │
│  │        开始同步                      │   │
│  └─────────────────────────────────────┘   │
│                                              │
├─────────────────────────────────────────────┤
│  同步进度：                                  │
│  ████████████░░░░░░░░░░░░░░ 50% (5/10)      │
│                                              │
│  当前任务：正在同步第 5 个文档               │
│                                              │
│  同步记录：                                  │
│  ✓ Task-1 → Document-1                      │
│  ✓ Task-2 → Document-2                      │
│  ✓ Task-3 → Document-3                      │
│  ✓ Task-4 → Document-4                      │
│  ⟳ Task-5 → Document-5 (同步中...)          │
│  ⏸ Task-6 → Document-6 (等待中)            │
│  ⏸ Task-7 → Document-7 (等待中)            │
│  ...                                        │
└─────────────────────────────────────────────┘
```

**功能要求**：
- 目标服务器地址输入框（带格式验证）
- 待同步仓库下拉框（从数据库读取可用仓库列表）
- 开始同步按钮
- 同步进度条
- 同步状态实时更新（使用轮询或 WebSocket）
- 同步记录列表（显示每个 Task 和 Document 的同步状态）

#### 3.3.2 同步历史页面（可选）

**页面路径**：`/sync/history`

**功能要求**：
- 显示历史同步记录
- 按时间倒序排列
- 显示同步状态、同步时间、同步数据量
- 支持查看同步详情

## 4. 数据结构

### 4.1 Repository 表结构

```go
type Repository struct {
    ID         uint      `gorm:"primaryKey"`
    Name       string    `gorm:"index"`
    URL        string
    Branch     string
    Status     string
    CreatedAt  time.Time
    UpdatedAt  time.Time
    Metadata   string    `gorm:"type:text"`  // JSON 格式存储其他字段
}
```

### 4.2 Task 表结构

```go
type Task struct {
    ID          uint      `gorm:"primaryKey"`
    RepositoryID string   `gorm:"index"`
    TaskType    string   `gorm:"index"`
    Status      string
    DocumentID  *uint    `gorm:"index"`  // 关联 Document ID
    CreatedAt   time.Time
    UpdatedAt   time.Time
    Metadata    string   `gorm:"type:text"`  // JSON 格式存储其他字段
}
```

### 4.3 Document 表结构

```go
type Document struct {
    ID          uint      `gorm:"primaryKey"`
    RepositoryID string   `gorm:"index"`
    TaskID      uint     `gorm:"index"`  // 关联 Task ID
    DocumentType string  `gorm:"index"`
    Content     string   `gorm:"type:text"`
    Language    string
    CreatedAt   time.Time
    UpdatedAt   time.Time
    Metadata    string   `gorm:"type:text"`  // JSON 格式存储其他字段
}
```

### 4.4 ID 映射关系

**内存映射结构**（同步过程中临时存储）：
```go
type SyncContext struct {
    TaskIDMapping    map[uint]uint      // A 的 Task ID → B 的 Task ID
    DocumentIDMapping map[uint]uint      // A 的 Document ID → B 的 Document ID
}
```

## 5. 错误处理

### 5.1 网络错误

- **目标服务器不可达**：提示用户检查目标服务器地址
- **网络超时**：提供重试机制
- **目标服务器返回错误**：记录错误日志，继续同步下一个 Document

### 5.2 数据错误

- **数据格式错误**：跳过当前 Document，记录错误日志
- **数据关联错误**：跳过当前 Document，记录错误日志
- **Repository 不存在**：执行 Repository 同步后重试创建 Task

### 5.3 事务处理

- 每个 Document 的同步是一个独立事务
- 失败不影响其他 Document
- 最终同步结果包含成功和失败的统计

## 6. 性能要求

- 单个 Document 同步时间 < 5 秒
- 支持 100 个 Document 以内的批量同步
- 同步过程中不影响实例 A 和 B 的正常使用
- 同步状态实时更新（每秒至少更新一次）

## 7. 安全要求

- **认证**：所有同步接口需要认证（使用 API Key 或 Token）
- **权限校验**：检查用户是否有权限同步指定仓库的数据
- **数据加密**：生产环境建议使用 HTTPS
- **防重放攻击**：使用同步 ID 或时间戳防止重复请求

## 8. 扩展性考虑

### 8.1 未来扩展方向

- 支持更多数据表的同步（如 Hint、DocRating 等）
- 支持增量同步（只同步新增或修改的数据）
- 支持双向同步（A ↔ B）
- 支持多实例链式同步（A → B → C）
- 支持同步调度（定时同步）

### 8.2 架构考虑

- 同步逻辑作为独立 Service，方便未来扩展
- 同步接口设计为通用格式，便于支持更多数据表
- 使用抽象层隔离不同数据表的同步逻辑

---

## 变更记录表

| 版本 | 日期 | 变更内容 | 作者 |
|------|------|---------|------|
| 1.0 | 2024-01-01 | 初始版本 | AI |
| 1.1 | 2026-02-10 | 增加 Repository 同步前置步骤与接口 | AI |
