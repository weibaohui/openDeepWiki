# 错误处理规范

本文档定义错误处理的方式和规范。

## 核心原则

1. **错误必须可分类**
2. **错误必须被处理**
3. **错误必须可追溯**

## 错误定义方式

### 方式一：标准错误变量

```go
package service

import "errors"

var (
    ErrUserAlreadyExists = errors.New("user already exists")
    ErrUserNotFound      = errors.New("user not found")
    ErrInvalidPassword   = errors.New("invalid password")
    ErrPermissionDenied  = errors.New("permission denied")
)
```

### 方式二：业务错误类型

```go
package errors

type BizError struct {
    Code    string // 错误码
    Message string // 错误消息
}

func (e *BizError) Error() string {
    return e.Message
}

// 预定义业务错误
var (
    ErrUserNotFound = &BizError{
        Code:    "USER_NOT_FOUND",
        Message: "user not found",
    }
    ErrUserAlreadyExists = &BizError{
        Code:    "USER_ALREADY_EXISTS",
        Message: "user already exists",
    }
)
```

## 错误包装

使用 `fmt.Errorf` 和 `%w` 包装错误：

```go
func (s *userService) Create(ctx context.Context, req CreateUserRequest) (*UserDTO, error) {
    user, err := s.userRepo.Create(ctx, user)
    if err != nil {
        return nil, fmt.Errorf("failed to create user: %w", err)
    }
    return toUserDTO(user), nil
}
```

## 错误判断

使用 `errors.Is` 和 `errors.As`：

```go
// 判断错误类型
if errors.Is(err, repository.ErrNotFound) {
    return nil, ErrUserNotFound
}

// 提取错误信息
var bizErr *BizError
if errors.As(err, &bizErr) {
    // 处理业务错误
}
```

## Repository 层错误

```go
package repository

import "errors"

var (
    ErrNotFound     = errors.New("record not found")
    ErrDuplicateKey = errors.New("duplicate key")
)

func (r *userRepository) GetByID(ctx context.Context, id string) (*domain.User, error) {
    var model UserModel
    err := r.db.WithContext(ctx).Where("id = ?", id).First(&model).Error
    
    if errors.Is(err, gorm.ErrRecordNotFound) {
        return nil, ErrNotFound  // 转换为 repository 错误
    }
    if err != nil {
        return nil, fmt.Errorf("failed to get user: %w", err)
    }
    
    return toDomain(&model), nil
}
```

## Handler 层错误转换

```go
package response

func FromError(c *gin.Context, err error) {
    // 业务错误
    var bizErr *errors.BizError
    if errors.As(err, &bizErr) {
        c.JSON(http.StatusBadRequest, Response{
            Code:    bizErr.Code,
            Message: bizErr.Message,
        })
        return
    }

    // 已知错误
    switch {
    case errors.Is(err, service.ErrUserNotFound):
        NotFound(c, err)
    case errors.Is(err, service.ErrUserAlreadyExists):
        Conflict(c, err)
    case errors.Is(err, service.ErrPermissionDenied):
        Forbidden(c, err)
    default:
        InternalError(c, err)
    }
}
```

## 禁止事项

```go
// ❌ 直接返回未分类的错误
func (s *userService) Create(ctx context.Context, req CreateUserRequest) (*UserDTO, error) {
    return nil, fmt.Errorf("something went wrong")  // 禁止！
}

// ❌ 吞掉错误
func (s *userService) Create(ctx context.Context, req CreateUserRequest) (*UserDTO, error) {
    user, _ := s.userRepo.Create(ctx, user)  // 禁止！
    return toUserDTO(user), nil
}

// ❌ panic 替代错误返回
func (s *userService) Create(ctx context.Context, req CreateUserRequest) *UserDTO {
    user, err := s.userRepo.Create(ctx, user)
    if err != nil {
        panic(err)  // 禁止！
    }
    return toUserDTO(user)
}

// ❌ 在错误中包含敏感信息
return nil, fmt.Errorf("password %s is invalid", password)  // 禁止！
```

## 错误日志

```go
func (s *userService) Create(ctx context.Context, req CreateUserRequest) (*UserDTO, error) {
    user, err := s.userRepo.Create(ctx, user)
    if err != nil {
        klog.V(2).ErrorS(err, "failed to create user", 
            "email", req.Email,
        )
        return nil, fmt.Errorf("failed to create user: %w", err)
    }
    return toUserDTO(user), nil
}
```

## 相关文档

- [Response 规范](./12-Response规范.md)
- [Service 规范](./04-Service规范.md)
