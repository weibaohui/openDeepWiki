# 事件机制（实时状态与解耦通信）架构优化建议

## 1. 现状与问题定位

当前系统的"状态变化传播"主要依赖前端轮询与后端写死的状态更新逻辑：

- 前端通过定时轮询拉取仓库/任务/文档状态  
  - [RepoDetail.tsx](../../../frontend/src/pages/RepoDetail.tsx#L43-L47)：每 3 秒轮询一次仓库详情、任务列表、文档列表  
  - [Home.tsx](../../../frontend/src/pages/Home.tsx#L49-L53)：每 5 秒轮询一次仓库列表
- 后端状态更新散落在不同 goroutine 中，缺少统一"状态变化事件"的发布与订阅能力  
  - [RepositoryService.runTasksAsync](../../../backend/internal/service/repository.go#L151-L182)：在单个 goroutine 串行跑任务，但未正确更新仓库最终状态  
  - [TaskService.Run](../../../backend/internal/service/task.go#L41-L136)：在任务运行过程中更新 task 状态并写 DB，并调用 UpdateRepositoryStatus 更新仓库状态，但不会对外广播变化

这会带来几个架构层面的长期问题：

1) 体验与资源浪费  
- 轮询在“无变化”时产生大量无效请求；变化发生时也只能在下一次轮询被动发现，实时性差。

2) 系统耦合与扩展性差  
- “状态变化 -> UI 刷新”被固定在“HTTP 拉取”模式，后续扩展（例如：实时日志流、增量进度、任务队列排队信息）会越来越难。

3) 任务/仓库状态的归因不清晰  
- 没有统一事件流，排障只能看散落日志与 DB 状态，缺乏“发生了什么”的可重放记录。

## 2. 目标架构（优先建议：后端事件总线 + SSE）

推荐落地路径（从低成本到可扩展）：

### 2.1 组件拆分

- **EventBus（进程内事件总线）**：负责发布/订阅事件（Task/Repo/Doc 等领域事件）
- **EventStream（SSE 事件流）**：为前端提供按 repo 维度的实时推送（EventSource）
- **Publisher（发布者）**：在服务层（RepositoryService/TaskService/DocumentService）产生日志/状态变化事件并发布
- **Consumer（消费者）**：前端 RepoDetail/Home 等页面订阅 SSE，收到事件后局部刷新或直接应用增量更新

为什么建议 SSE 而不是 WebSocket：

- SSE 对“服务器主动推送、客户端只读”的场景更简单稳定（事件序列 + 自动重连）
- gin/HTTP 基础设施更容易接入（对连接管理与鉴权也更直观）
- 业务上主要是状态更新与日志推送，不强依赖双向通信

## 3. 事件模型设计（建议）

### 3.1 事件协议（统一 envelope）

建议统一使用如下事件结构（字段可按实际裁剪）：

| 字段       | 说明                                                                   |
| ---------- | ---------------------------------------------------------------------- |
| type       | 事件类型，例如 repo.status_changed / task.status_changed / doc.created |
| ts         | 事件时间戳（毫秒）                                                     |
| repo_id    | 关联仓库（可选）                                                       |
| task_id    | 关联任务（可选）                                                       |
| payload    | 事件内容（JSON 对象）                                                  |
| request_id | 关联一次操作链路（可选，便于排障）                                     |

### 3.2 事件类型（最小可用集合）

| 事件类型            | 触发点                                                  | payload 建议                                   |
| ------------------- | ------------------------------------------------------- | ---------------------------------------------- |
| repo.status_changed | 仓库状态迁移（cloning/ready/analyzing/completed/error） | {from,to,error_msg?}                           |
| task.status_changed | 任务状态迁移（pending/running/completed/failed）        | {from,to,error_msg?,started_at?,completed_at?} |
| doc.created         | 文档生成成功                                            | {doc_id,title,filename}                        |
| task.progress       | 任务内部阶段进度（静态分析/LLM/保存文档）               | {phase,percent?,message?}                      |
| log.append          | 任务日志追加（可选）                                    | {level,message}                                |

注意：事件与 DB 状态并不冲突，事件用于实时传播与解耦；DB 仍是最终一致的事实源。

## 4. 与当前代码的映射（改造点）

### 4.1 后端发布事件（服务层）

在以下位置发布事件最合适：

- 仓库状态变化：  
  - clone 开始/成功/失败：[RepositoryService.cloneAndAnalyze](../../../backend/internal/service/repository.go#L70-L102)
  - run-all 启动：[RepositoryService.RunAllTasks](../../../backend/internal/service/repository.go#L131-L149)
  - 仓库状态聚合更新：[TaskService.UpdateRepositoryStatus](../../../backend/internal/service/task.go#L233-L292)
- 任务状态变化：  
  - pending -> running、running -> completed/failed：[TaskService.Run](../../../backend/internal/service/task.go#L59-L62,125-L127)
  - reset/force reset：[TaskService.Reset](../../../backend/internal/service/task.go#L173-L177)、[TaskService.ForceReset](../../../backend/internal/service/task.go#L201-L204)
- 文档生成成功：  
  - [DocumentService.Create](../../../backend/internal/service/document.go#L29-L43)

### 4.2 后端事件流 API（SSE）

建议新增接口（示例）：

- `GET /api/repositories/:id/events`：返回 SSE 流，仅推送与该 repo 相关事件  

路由可在 [router.go](../../../backend/internal/router/router.go#L31-L67) 中新增一个 `repos.GET("/:id/events", ...)`。

鉴权建议（强烈建议与配置管理一起做）：  
- 事件流也需要鉴权，否则相当于公开推送仓库运行信息。

### 4.3 前端接入

以仓库详情页为例：

- 将 [RepoDetail.tsx](../../../frontend/src/pages/RepoDetail.tsx#L43-L47) 的 setInterval 轮询替换为 EventSource  
- 收到 `task.status_changed/doc.created/repo.status_changed` 后：
  - 轻量方案：触发一次 fetchData（仍走 HTTP 拉取，但只在"有变化"时拉）
  - 进阶方案：直接把 payload 合并进本地 state（减少接口调用）

Home 列表页也可按 repo 级别订阅"仓库状态变化"事件，或保留低频轮询（例如 30s）作为兜底。

## 5. 实施建议

### 5.1 第一阶段：完善状态聚合逻辑

首先解决最基础的问题：

1. 修复 [RepositoryService.runTasksAsync](../../../backend/internal/service/repository.go#L151-L182) 中的仓库状态更新问题，在循环结束后显式调用 UpdateRepositoryStatus
2. 确保所有状态变更点都调用 UpdateRepositoryStatus
3. 添加必要的日志以便追踪状态变化

### 5.2 第二阶段：引入事件机制

在状态聚合完善的基础上，引入事件机制：

1. 实现简单的进程内 EventBus
2. 在关键状态变更点发布事件
3. 新增 SSE 接口 `/api/repositories/:id/events`
4. 前端替换轮询为 EventSource 订阅

### 5.3 第三阶段：分布式演进（可选）

当需要多实例部署时：

- 将 EventBus 升级为 Redis Pub/Sub 或其他分布式消息系统
- 保持事件协议不变，只需替换底层实现

## 6. 推荐的分阶段落地计划（不依赖大重构）

### 阶段 A：修复状态聚合 + 基础事件机制

1) 修复 [RepositoryService.runTasksAsync](../../../backend/internal/service/repository.go#L151-L182) 的仓库状态更新问题
2) 后端引入 EventBus（内存）并新增 SSE 接口  
3) 服务层在关键状态变更处发布事件（仓库/任务/文档）  
4) 前端使用 EventSource，收到事件后触发 fetchData（替代 setInterval）

验收标准：

- 仓库状态聚合逻辑正确，所有任务完成后能正确更新仓库状态
- RepoDetail 页面不再 3 秒轮询
- 任务状态变化在 1s 内反映到 UI
- 后端请求量明显下降（无变化时接近 0）

### 阶段 B：增量更新与实时日志

1) 增加 task.progress/log.append 事件  
2) 前端按事件 payload 增量更新 tasks/documents，减少全量拉取  
3) 增加 UI：任务运行阶段/日志面板

## 7. 当前实现的改进点

当前代码相比文档描述已有部分改进：

- [TaskService](../../../backend/internal/service/task.go) 中已实现了 [UpdateRepositoryStatus](../../../backend/internal/service/task.go#L233-L292) 方法，用于根据任务集合状态聚合计算仓库状态
- 每个任务状态变更时都会调用此方法更新仓库状态

但仍存在的问题：

- [RepositoryService.runTasksAsync](../../../backend/internal/service/repository.go#L151-L182) 循环结束后未显式更新仓库状态，可能导致状态不一致
- 缺少事件发布机制，前端仍需轮询获取状态变化

建议的改进方向：

1. 在 runTasksAsync 循环结束后显式调用 UpdateRepositoryStatus
2. 引入事件机制，将状态变化实时推送给前端
3. 保持 UpdateRepositoryStatus 作为核心聚合逻辑，确保状态一致性

