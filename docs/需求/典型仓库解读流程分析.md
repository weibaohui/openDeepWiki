拆解 openDeepWiki 的典型工作流，设计 Agent、Skills、Tools 的协作架构。

## 一、系统总体架构思路

首先明确三个核心概念的分层：
- **Tools**: 原子能力，与外部系统交互（文件系统、Git、代码解析器、LLM API等）
- **Skills**: 组合能力，封装业务逻辑（代码分析、文档生成、质量检查等）
- **Agent**: 智能体，具备角色定义、上下文记忆、任务规划与执行能力

## 二、完整工作步骤拆解

### 阶段一：仓库预处理与大纲生成

#### 步骤 1：仓库获取与初始化
**目标**: 拉取代码并建立基础认知

| 维度       | 内容                                                                                                                                                                         |
| ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **参与者** | **Agent**: `RepoInitializer` (仓库初始化专员)                                                                                                                                |
| **Tools**  | `GitTool.clone()`, `FileSystemTool.ls()`, `FileSystemTool.read()`                                                                                                            |
| **Skills** | `RepoDetectionSkill`(仓库类型识别), `StructureAnalysisSkill`(结构分析)                                                                                                       |
| **目的**   | 获取代码并识别仓库基本属性（语言、框架、规模）                                                                                                                               |
| **如何做** | 1. Agent 调用 GitTool 克隆仓库到工作目录<br>2. 读取根目录文件（README/package.json/go.mod等）<br>3. 统计代码文件类型分布<br>4. 识别技术栈（Python项目/Go微服务/React前端等） |
| **效果**   | 生成 `RepoMeta` 对象：{type, languages, entry_files, size, framework                                                                                                         |
| }          |

#### 步骤 2：全局结构预读与目录生成
**目标**: 生成三级文档大纲（目录+章节+标题）

| 维度       | 内容                                                                                                                                                                                                                                                                                                                                                                                        |
| ---------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **参与者** | **Agent**: `ArchitectAgent` (架构师) - 负责顶层设计                                                                                                                                                                                                                                                                                                                                         |
| **Tools**  | `CodeParserTool.get_file_tree()`, `ASTAnalyzerTool.get_dependencies()`, `GitTool.get_commit_history()`                                                                                                                                                                                                                                                                                      |
| **Skills** | `HierarchyMappingSkill`(层级映射), `DocStructureSkill`(文档结构设计)                                                                                                                                                                                                                                                                                                                        |
| **目的**   | 基于仓库结构生成文档骨架，不深入代码细节，只做宏观规划                                                                                                                                                                                                                                                                                                                                      |
| **如何做** | 1. 获取文件树，识别模块边界（有__init__.py的文件夹/go package等）<br>2. 分析依赖关系，找出核心模块 vs 辅助模块<br>3. 结合仓库类型套用模板（Web项目：路由-控制器-模型；CLI工具：命令-参数-处理逻辑）<br>4. Agent 运用 DocStructureSkill 生成三级大纲：<br>   - 一级：核心概念/架构设计/使用指南/开发规范<br>   - 二级：各章节（如"路由系统"）<br>   - 三级：具体标题（如"动态路由匹配机制"） |
| **效果**   | 产出 `DocOutline`：JSON结构化的三级目录，包含每个节点的预估复杂度权重                                                                                                                                                                                                                                                                                                                       |

---

### 阶段二：深度分析与内容规划

#### 步骤 3：标题级探索与代码定位
**目标**: 为单个三级标题找到对应的代码证据和相关文件

| 维度       | 内容                                                                                                                                                                                                                                                                                                                    |
| ---------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **参与者** | **Agent**: `ExplorerAgent` (探索者)                                                                                                                                                                                                                                                                                     |
| **Tools**  | `SemanticSearchTool.search()`(向量检索), `GrepTool.regex_search()`, `CodeParserTool.extract_functions()`, `DependencyGraphTool.trace()`                                                                                                                                                                                 |
| **Skills** | `CodeRelevanceSkill`(代码相关性判断), `ContextExtractionSkill`(上下文提取)                                                                                                                                                                                                                                              |
| **目的**   | 针对大纲中的第X个标题，找到"需要解读哪些代码文件"                                                                                                                                                                                                                                                                       |
| **如何做** | 1. Agent 接受任务：标题="动态路由匹配机制"<br>2. 调用 SemanticSearchTool 用标题语义搜索相关代码片段<br>3. 用 GrepTool 搜索 keywords（如"router"、"match"、"dynamic"）<br>4. 解析关键文件的 AST，提取函数/类定义<br>5. Trace 依赖图，找出上下游关联文件<br>6. Agent 判断：哪些文件是核心(primary)，哪些是参考(secondary) |
| **效果**   | 产出 `TitleContext`：{title, primary_files[], secondary_files[], key_functions[], data_flow_hints                                                                                                                                                                                                                       |
| }          |

#### 步骤 4：小节标题生成与内容结构化
**目标**: 将三级标题拆分为可撰写的小节（4-6个小节）

| 维度       | 内容                                                                                                                                                                                                                                                                                                                                                                 |
| ---------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **参与者** | **Agent**: `PlannerAgent` (内容规划师)                                                                                                                                                                                                                                                                                                                               |
| **Skills** | `ArticleStructuringSkill`(文章结构化), `TechnicalWritingSkill`(技术写作规范)                                                                                                                                                                                                                                                                                         |
| **目的**   | 设计文章内部结构，确保逻辑递进                                                                                                                                                                                                                                                                                                                                       |
| **如何做** | 1. Agent 读取 TitleContext 中的代码摘要<br>2. 分析代码复杂度：简单函数直接说明，复杂机制拆分步骤<br>3. 应用写作模板：<br>   - 概念速览（What）<br>   - 代码位置（Where）<br>   - 执行流程（How）- 可再细分：初始化→匹配→返回<br>   - 设计意图（Why）<br>   - 使用示例（Example）<br>   - 边界情况（Edge Cases）<br>4. 生成小节标题列表，标记每个小节需要哪些代码证据 |
| **效果**   | 产出 `SectionPlan`：[                                                                                                                                                                                                                                                                                                                                                |
    {section_name, code_refs[], writing_goal, estimated_length
    }] |

---

### 阶段三：内容撰写与质量控制

#### 步骤 5：小节内容撰写
**目标**: 基于代码证据生成自然语言解释

| 维度       | 内容                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| ---------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **参与者** | **Agent**: `WriterAgent` (技术作者)                                                                                                                                                                                                                                                                                                                                                                                                                         |
| **Tools**  | `LLMTool.generate()`, `CodeParserTool.get_snippet()`, `DiagramTool.generate_mermaid()`                                                                                                                                                                                                                                                                                                                                                                      |
| **Skills** | `CodeExplanationSkill`(代码解释), `NarrativeFlowSkill`(叙事流程), `ExampleGenerationSkill`(示例生成)                                                                                                                                                                                                                                                                                                                                                        |
| **目的**   | 将代码转化为人类可读的技术文档                                                                                                                                                                                                                                                                                                                                                                                                                              |
| **如何做** | 1. Agent 读取 SectionPlan 中的第一个小节<br>2. 调用 CodeParserTool 提取相关代码片段（自动截断关键部分）<br>3. 使用 CodeExplanationSkill：<br>   - 对代码进行逐行/逐块注释<br>   - 识别设计模式（工厂/观察者/策略等）<br>   - 生成 Mermaid 流程图（调用 DiagramTool）<br>4. 使用 NarrativeFlowSkill 组织语言：<br>   - 先给结论，再给细节<br>   - 用比喻解释抽象概念<br>   - 保持技术准确性<br>5. 若需要示例，调用 ExampleGenerationSkill 构造最小可运行示例 |
| **效果**   | 产出 `SectionDraft`：Markdown 格式的完整小节内容，包含代码块、图表、说明文字                                                                                                                                                                                                                                                                                                                                                                                |

#### 步骤 6：查漏补缺与一致性检查
**目标**: 验证内容完整性，填补缺失信息

| 维度       | 内容                                                                                                                                                                                                                                                                                                                                                                                                                              |
| ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **参与者** | **Agent**: `ReviewerAgent` (审查员)                                                                                                                                                                                                                                                                                                                                                                                               |
| **Tools**  | `GapAnalysisTool.compare()`, `ConsistencyCheckTool.verify()`, `CrossRefTool.check_links()`                                                                                                                                                                                                                                                                                                                                        |
| **Skills** | `CompletenessCheckSkill`(完整性检查), `TechnicalAccuracySkill`(技术准确性验证), `StyleCheckSkill`(风格检查)                                                                                                                                                                                                                                                                                                                       |
| **目的**   | 确保文档覆盖所有关键代码点，前后一致                                                                                                                                                                                                                                                                                                                                                                                              |
| **如何做** | 1. **代码覆盖检查**：用 GapAnalysisTool 比对 SectionDraft 中提到的代码 vs TitleContext 中标记的关键函数，检查是否有重要函数未解释<br>2. **逻辑一致性**：验证前文提到的概念在后文有解释，示例代码与描述一致<br>3. **交叉引用**：检查是否引用了其他章节的内容，确保链接有效<br>4. **风格检查**：确保术语统一（如别前面叫"路由"后面叫"Router"）<br>5. Agent 生成 `ReviewReport`：{missing_points[], inconsistencies[], suggestions[] |
| }          |
| **效果**   | 产出修改建议，或直接输出修复后的 `SectionFinal`                                                                                                                                                                                                                                                                                                                                                                                   |

#### 步骤 7：章节组装与优化
**目标**: 合并所有小节，形成完整章节

| 维度       | 内容                                                                                                                                                    |
| ---------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **参与者** | **Agent**: `EditorAgent` (编辑)                                                                                                                         |
| **Skills** | `ContentAssemblySkill`(内容组装), `TransitionOptimizationSkill`(过渡优化), `SummaryGenerationSkill`(摘要生成)                                           |
| **目的**   | 确保章节内聚性，添加过渡段落                                                                                                                            |
| **如何做** | 1. 收集该章节下所有 SectionFinal<br>2. 检查小节间逻辑流，添加过渡句<br>3. 生成章节摘要（TL;DR）<br>4. 统一代码块样式、图表编号<br>5. 添加"相关章节"链接 |
| **效果**   | 产出 `ChapterDocument`：完整的可发布章节                                                                                                                |

---

### 阶段四：全局协调与特殊处理

#### 并行处理控制（协调层）
**目标**: 管理多章节并行生成的依赖关系

| 维度       | 内容                                                                                                                                                                                                                                                                      |
| ---------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **参与者** | **Agent**: `OrchestratorAgent` (协调者) - 唯一长期运行的 Agent                                                                                                                                                                                                            |
| **Skills** | `DependencyManagementSkill`(依赖管理), `TaskSchedulingSkill`(任务调度), `StateManagementSkill`(状态管理)                                                                                                                                                                  |
| **目的**   | 维护全局状态，处理章节间依赖（如第二章引用第一章的概念）                                                                                                                                                                                                                  |
| **如何做** | 1. 维护 `GlobalContext`：已完成的章节摘要、关键概念定义表<br>2. 当 WriterAgent 卡住时（如发现依赖其他未生成章节），Orchestrator 决定：阻塞等待 / 先写占位符 / 调整顺序<br>3. 监控各 Agent 工作进度，防止重复处理<br>4. 处理冲突（如两个章节引用了同一代码文件但解释矛盾） |
| **效果**   | 确保整体文档的一致性和生成效率                                                                                                                                                                                                                                            |

#### 特殊场景处理
**代码更新检测**：
- **Agent**: `SyncAgent` (同步专员)
- **Tools**: `GitTool.diff()`, `ChangeDetectionTool.scan()`
- **触发**: 当仓库有新 commit 时
- **动作**: 重新执行步骤3-6，仅更新受影响章节，标记文档版本

**交互式问答增强**：
- **Agent**: `QAAgent` (问答助手)
- **Skills**: `RetrievalSkill`(检索), `SynthesisSkill`(综合)
- **能力**: 用户提问时，Agent 查询已生成文档+原始代码，给出精准回答，并可选地将 QA 沉淀为新章节

---

## 三、完整能力清单

### Tools 清单（原子能力）

```yaml
GitTools:
  - clone(repo_url, branch): 克隆指定分支
  - diff(commit_hash): 获取变更差异
  - log(file_path): 获取文件提交历史

FileSystemTools:
  - ls(dir, recursive): 列出目录结构
  - read(file_path, offset, limit): 读取文件内容
  - grep(pattern, path): 正则搜索
  - stat(file_path): 文件元信息

CodeAnalysisTools:
  - parse_ast(file_path): 生成 AST
  - extract_functions(file_path): 提取函数列表
  - get_call_graph(entry_point): 生成调用图
  - calculate_complexity(file_path): 计算圈复杂度

SearchTools:
  - semantic_search(query): 基于嵌入的语义搜索
  - symbol_search(symbol_name): 精确符号搜索

GenerationTools:
  - llm_generate(prompt, context): 调用 LLM 生成内容
  - generate_mermaid(code_snippet): 生成流程图
  - generate_diagram(description): 生成架构图

QualityTools:
  - check_links(doc_content): 检查内部链接有效性
  - plagiarism_check(text): 检查与代码的重复度（避免大段复制代码而不解释）
```

### Skills 清单（组合业务能力）

```yaml
RepositoryUnderstanding:
  - RepoDetectionSkill: 识别技术栈和项目类型
  - StructureAnalysisSkill: 分析目录结构和模块边界
  - DependencyMappingSkill: 映射模块间依赖关系

ContentPlanning:
  - DocStructureSkill: 根据项目类型生成文档大纲模板
  - HierarchyMappingSkill: 将代码结构映射为文档层级
  - CodeRelevanceSkill: 判断代码与写作目标的相关性

Writing:
  - CodeExplanationSkill: 将代码逻辑转化为自然语言
  - NarrativeFlowSkill: 组织技术叙事结构
  - ExampleGenerationSkill: 生成使用示例
  - DiagramDescriptionSkill: 生成图表描述文字

QualityAssurance:
  - CompletenessCheckSkill: 检查代码覆盖率
  - ConsistencyCheckSkill: 检查术语和逻辑一致性
  - TechnicalAccuracySkill: 验证技术描述的正确性
  - StyleCheckSkill: 检查写作风格和格式规范

Coordination:
  - DependencyResolutionSkill: 解决章节间依赖
  - ContextManagementSkill: 维护全局上下文和记忆
```

### Agent 清单（角色定义）

```yaml
OrchestratorAgent:
  role: "项目总协调"
  system_prompt: "你是 openDeepWiki 的总控，负责管理文档生成全流程..."
  skills: [DependencyManagementSkill, TaskSchedulingSkill, StateManagementSkill]
  tools: [] # 主要协调其他 Agent，不直接操作工具
  memory: 长期维护 GlobalContext 和 ProjectState

RepoInitializer:
  role: "仓库初始化专员"
  system_prompt: "你负责拉取代码并做初步分析..."
  skills: [RepoDetectionSkill, StructureAnalysisSkill]
  tools: [GitTools.clone, FileSystemTools.ls, FileSystemTools.read, CodeAnalysisTools.parse_ast]
  memory: 短期，仅维护当前仓库元数据

ArchitectAgent:
  role: "文档架构师"
  system_prompt: "你设计文档的整体结构，不做细节撰写..."
  skills: [DocStructureSkill, HierarchyMappingSkill]
  tools: [SearchTools.semantic_search, FileSystemTools.grep]
  memory: 短期，基于 RepoMeta 生成 Outline

ExplorerAgent:
  role: "代码探索者"
  system_prompt: "你深入代码库，为特定主题找到相关代码证据..."
  skills: [CodeRelevanceSkill, ContextExtractionSkill, DependencyMappingSkill]
  tools: [SearchTools.semantic_search, SearchTools.symbol_search, CodeAnalysisTools.get_call_graph, CodeAnalysisTools.extract_functions]
  memory: 中期，维护当前标题的 TitleContext

PlannerAgent:
  role: "内容规划师"
  system_prompt: "你将写作目标拆解为可执行的小节..."
  skills: [ArticleStructuringSkill, TechnicalWritingSkill]
  tools: [CodeAnalysisTools.calculate_complexity] # 用于评估需要多少笔墨
  memory: 短期，基于 TitleContext 生成 SectionPlan

WriterAgent:
  role: "技术作者"
  system_prompt: "你将代码解释为人类可读的技术文档..."
  skills: [CodeExplanationSkill, NarrativeFlowSkill, ExampleGenerationSkill, DiagramDescriptionSkill]
  tools: [CodeAnalysisTools.parse_ast, GenerationTools.llm_generate, GenerationTools.generate_mermaid, FileSystemTools.read]
  memory: 短期，仅当前 SectionPlan

ReviewerAgent:
  role: "质量审查员"
  system_prompt: "你检查文档的完整性、准确性和一致性..."
  skills: [CompletenessCheckSkill, ConsistencyCheckSkill, TechnicalAccuracySkill, StyleCheckSkill]
  tools: [QualityTools.check_links, QualityTools.plagiarism_check, FileSystemTools.read]
  memory: 短期，对比 SectionDraft 与 TitleContext

EditorAgent:
  role: "编辑"
  system_prompt: "你组装最终文档，优化阅读体验..."
  skills: [ContentAssemblySkill, TransitionOptimizationSkill, SummaryGenerationSkill]
  tools: [QualityTools.check_links]
  memory: 中期，组装 ChapterDocument

SpecializedAgents:
  QAAgent:
    role: "问答助手"
    skills: [RetrievalSkill, SynthesisSkill, CodeExplanationSkill]
    tools: [SearchTools.semantic_search, GenerationTools.llm_generate]
  
  SyncAgent:
    role: "同步专员"
    skills: [ChangeDetectionSkill, IncrementalUpdateSkill]
    tools: [GitTools.diff, GitTools.log]
```

## 四、关键协作流程图

```
[OrchestratorAgent] 全局协调
       │
       ▼
[RepoInitializer] ──Tools──> GitClone, FileScan
       │
       ▼
[ArchitectAgent] ──Skills──> 生成 DocOutline
       │
       ├─── 并行触发多个 ───┐
       ▼                   ▼
[ExplorerAgent]      [ExplorerAgent]  (按章节并行)
       │                   │
       ▼                   ▼
生成 TitleContext     生成 TitleContext
       │                   │
       ▼                   ▼
[PlannerAgent]        [PlannerAgent]
       │                   │
       ▼                   ▼
生成 SectionPlan      生成 SectionPlan
       │                   │
       ▼                   ▼
[WriterAgent] × N 次迭代 (逐小节撰写)
       │
       ▼
[ReviewerAgent] 检查 ──反馈──> WriterAgent (循环直到通过)
       │
       ▼
[EditorAgent] 组装章节
       │
       ▼
返回 [OrchestratorAgent] ──> 合并到全局文档
```

## 五、关键设计决策建议

1. **分支管理**: 在步骤1中，RepoInitializer 应该支持指定分支， ArchitectAgent 根据分支类型（main/dev/feature）调整文档侧重点（如 feature 分支侧重变更说明）

2. **缓存策略**: ExplorerAgent 的代码分析结果应缓存（存储向量嵌入），避免多 Agent 重复解析同一文件

3. **人机协同**: ReviewerAgent 发现严重技术理解错误时，应标记为"需人工确认"而非自动修复

4. **增量生成**: 支持"只解读 src/core 目录"或"只生成架构相关章节"的局部生成功能

5. **模板化**: ArchitectAgent 应内置模板库（微服务模板、前端组件库模板、算法库模板等），根据仓库类型自动选择

包括了全局协调层和质量控制层，每个角色（Agent）都有明确的职责边界、可复用的技能（Skills）和底层工具（Tools）支持。这样的分层设计可以让系统具备良好的扩展性——新增一种仓库类型只需调整 Skills，新增一种输出格式只需调整 WriterAgent。